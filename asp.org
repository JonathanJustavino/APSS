* ASP
** DONE Exercise 2.1

Translate this rule into english

#+begin_src prolog
%clingo child.lp
child(X,Y) :- parent(Y,X). %Rule 2.1
#+end_src

*** Solution

Solution X is a child of Y if Y is a parent of X.

** DONE Exercise 2.2

If we run clingo on the program consisting of rule (2.1)

and the rules:

#+begin_src prolog
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

then what stable model do you think it will produce?

*** Solution

Answer: SATISFIABLE
parent(ann,bob). parent(bob,carol). parent(bob,dan) child(bob,ann) child(carol,bob) child(dan,bob)

** Rules

A typical rule consists of a head and a body separated by the *if* symbol :- and with a period at the end

Rules not containing these symbols are viewed as the head without a body

The heads and bodies of rules are formed from /atoms/

#+begin_src prolog Rule 1.1
large(C) :- size(C,S1), size(uk,S2), S1 > S2.
#+end_src

#+begin_src prolog Rule 1.2
size(france,65). size(germany,83). size(italy,61). size(uk,64).
#+end_src

~large(C), size(C,S1), size(uk,S2), size(france,65), size(germany,83), size(italy,61), size(uk,64)~

Within an atom or comparison elements of three types can be seen: /symbolic constants/, /numeric constants/, and /variables/

*** Numeric Constants

A numeric constant is an integer in decimal notation beginning with a with a digit or the *minus* sign

*** Symbolic Constants

A symbolic constant represents is a string of letters, digits and underscores that begins with an lower-case letter

*** Variables

A variable is a string of letters, digits and underscores that begins with an upper-case letter

*** Atom

An atom consists of a /predicate symbol/ - a symbolic constant representing a property or a relation and an optional list of arguments in parentheses

*** Comparison

A comparison consists of two arguments separated by one of the symbols

~= != < > <= >=~ (2.3)

*** Terms

Expressions that can serve as arguments in an atom or comparision are called /terms/

*** Ground

An atom, a rule or another syntactic expression is /ground/ if it does not contain variables

A fact is a ground atom

*CLINGO produces facts in response to rules.*

This can be clarified by considering ~instances~ of rule (1.1) the ground rules that can be obtained from it by substituting constants for variables

The presence of the atom ~large(france)~ in the stable model generated by CLINGO can be justified by the instance

#+begin_src prolog
large(france) :- size(france,65), size(uk,64), 65 > 64.
#+end_src

from rule 1.1 which is obtained from it by substituting the terms:

~france, 65~ and ~64~

for the variables:

~C, S1~, and ~S2~

Both atoms in the body of this instance are among the given facts and the comparison in the body is true.
Consequently this instance justifies including its head ~large(france)~ in the stable model

*** DONE Exercise 2.3

#+begin_src prolog Rule 1.1
large(C) :- size(C,S1), size(uk,S2), S1 > S2.
#+end_src

#+begin_src prolog Rule 1.2
size(france,65). size(germany,83). size(italy,61). size(uk,64).
#+end_src

#+begin_src prolog Rule 2.1
%clingo child.lp
child(X,Y) :- parent(Y,X).
#+end_src

#+begin_src prolog Rule 2.2
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

a. Which instance of rule (1.1) justifies including ~large(germany)~ in the stable model of the program?
   + instance ~large(germany) :- size(germany,83), size(uk,64), 83 > 64.~
b. Which instance of rule (2.1) justifies including ~child(dan,bob)~ in the stable model of program (2.1), (2.2)~
   + instance ~child(dan,bob) :- parent(bob,dan).~

*** DONE Exercise 2.4

Which of the following ground rules and instances of rule (1.1)

a. large(france) :- size(france,65), size(italy,61), 65 > 61.
   - not because the rule 1.1 dictates the comparison with uk instead of italy
b. large(italy) :- size(italy,61), size(uk,64), 61 > 64.
   + ~Instance~
c. large(italy) :- size(italy,83), size(uk,64), 83 > 64.
   + ~Instance~
d. large(7) :- size(7,7), size(uk,7), 7 > 7.
   + ~Instance~

** Comparison again

The last four among the relation symbols (2.3)

~< > <= >=~

are usually applied to numbers, but *CLINGO* allows to apply them to symbolic constants as well

E.g. according to the total order used by *CLINGO* for such comparisons, the symbol ~abracadabra~ is greater than 7

#+begin_src prolog
p :- abracadabra > 7
#+end_src

Stable model: ~p~

#+RESULTS:
clingo version 5.6.2
Reading from comp.lp
Solving...
Answer: 1
p
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

#+begin_src prolog
p :- abracadabra < 7
#+end_src

Stable model: \emptyset (empty model)

#+RESULTS:
clingo version 5.6.2
Reading from comp.lp
Solving...
Answer: 1

SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

** Total Order

The total order chosen by the designers of *CLINGO* has a minimal element and a maximal element denoted by ~#inf~ and ~#sup~

Stable models of some programs are infinite. Consider the example

#+begin_src prolog Rule 2.4
p(X) :- X > 7.
#+end_src

The instance

#+begin_src prolog
p(8) :- 8 > 7.
#+end_src

of this rule justifies including ~p(8)~ in the stable model

The instance

#+begin_src prolog
p(9) :- 9 > 7.
#+end_src

justifies including ~p(9)~ and so on

In response to rule (2.4) *CLINGO* produces an error message saying that there are "unsafe variable" in it

~indicating that the program containing this rule is likely to have an infinite stable model~

** Pooling

When a program contains a group of facts with the same predicate symbol, these facts can be "pooled together" using semicolons

#+begin_src prolog
size(france,65; german,83; italy,61; uk,64).
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from abrv.lp
Solving...
Answer: 1
size(france,65) size(german,83) size(italy,61) size(uk,64)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.5

#+begin_src prolog Rule 2.2
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

Use pooling to abbreviate line (2.2)

#+begin_src prolog
parent(ann,bob; bob,carol; bob,dan).
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from abrv.lp
Solving...
Answer: 1
parent(ann,bob) parent(bob,carol) parent(bob,dan)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.6

If you run *CLINGO* on the one-rule program

#+begin_src prolog
p(1,2; 2,4; 4,8; 8,16).
#+end_src

Then what stable model will it produce?

#+RESULTS:
clingo version 5.6.2
Reading from abrv.lp
Solving...
Answer: 1
p(1,2) p(2,4) p(4,8) p(8,16)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

** Directives and Comments

In addition to rules, a logic program may contain /directives/, which tell *CLINGO* how to process the rules and /comments/, which are intended for humans and are disregarded by *CLINGO*

*** show

A ~#show~ directive instructs *CLINGO* to show some elements of the stable model and suppress others

#+begin_src prolog (1.3) output
size(france,65) size(germany,83) size(italy,61) size(uk,64)
large(france) large(germany)
#+end_src

E.g. in the output (1.3) of program (1.1) and (1.2) the first four atoms are irrelevant, they simply repeat the facts included in the program

The output of interest is the list of countries inhabited by more people than the UK, which is given by the last two atoms

*CLINGO* can be instructed to "hide" all atoms that do not begin with the predicate symbol ~large~

#+begin_src prolog
#show large/1
#+end_src

#+begin_src prolog
size(france,65; germany,83; italy,61; uk,64; russia,142).

large(C) :- size(C,S1), size(uk,S2), S1 > S2.

%stelligkeit mit dazu schreiben
%#show large/1.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from sample3.lp
Solving...
Answer: 1
large(france) large(germany) large(russia)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.002s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

In ~#show~ directives and in other cases when referring to /predicate symbols/ used in a logic program, the *arity* is appended =:=the number of arguments= after a slash

In this case the predicate is unary and its arity is ~1~
Specifying the arity is crucial because *CLINGO* allows to use the same character string to represent several predicate symbols on different arities

E.g.

#+begin_src clingo
p. p(a). p(a,b).
#show p/0. #show p/2.
#+end_src

clingo will drop the atom ~p(a)~ from the output, since its predicate symbol ~p/1~ is different from bot ~p/0~ and ~p/2~

#+RESULTS:
clingo version 5.6.2
Reading from show.lp
Solving...
Answer: 1
p p(a,b)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** const

A ~#const~ directive allows to use a symbolic constant as a placeholder for another /constant/, /symbolic/ or /numeric/.

E.g the directive

#+begin_src prolog Rule 2.5
#const c0=uk.
#+end_src

instructs *CLINGO* to substitute ~uk~ for ~c0~ in the rest of the file.

In the presence of directive (2.5), the rule

#+begin_src prolog
large(C) :- size(C,S1), size(c0,S2), S1 > S2.
#+end_src

has the same meaning as (1.1)

** Arithmetic

In the language of *CLINGO*, complex terms can be built from constants and variables using the symbols

~+   *   **  /   \   | |~

for addition, multiplication, exponentiation, integer division, remainder, and absolute value

The symbol ~..~ is used to form intervals. E.g. the expression ~0..3~ denotes the set ~{0,1,2,3}~

To express that the value of ~N~ belongs to this set we write ~N = 0..3~ in this case the ~=~ symbol plays the same role as the symbol ~\in~ in standard mathematical notation

For example the rule:

#+begin_src prolog
p(N,N*N+N+41) :- N = 0..3.
#+end_src

expresses that the pair of integers $(x, x^{2} + x + 41)$ belongs to ~p/2~ whenever ~x~ a number between ~0~ and ~3~. The stable model of this one rule program is

#+RESULTS:
clingo version 5.6.2
Reading from arit.lp
Solving...
Answer: 1
p(0,41) p(1,43) p(2,47) p(3,53)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.7

For each of the given one-rule programs, predict what stable model *CLINGO* is going to produce

a. p(N,N*N+N+41) :- N+1 = 1..4.
   + ~p(0,41) p(1,43) p(2,47) p(3,53)~
b. p(N,N*N+N+41) :- N = -3..3, N >= 0.
   + ~p(0,41) p(1,43) p(2,47) p(3,53)~

=Explanation=: The output is the same for both =a.= and =b.= because of the constraints.
- The expression =a.= can be informally expressed as values for ~N~ that get substituted in the /instance/ ~p(N,N*N+N+41)~ need to satisfy the criteria that the respective ~value + 1~ is in the range of ~1..4~
- The expression =b.= can be informally expressed as values for ~N~ that get substituted in the /instance/ ~p(N,N*N+N+41)~ need to satisfy the criteria that the respective value is in the range from ~-3..3~ *AND* that ~value > 0~

*** DONE Exercise 2.8

Write a one-rule program that does not contain pooling and has the same stable model as the program from exercise (2.6)

#+begin_src prolog 2.6
p(1,2; 2,4; 4,8; 8,16).
#+end_src

#+begin_src prolog 2.8
p(X, X*2) :- N = 1..8, N\2 == 0.
#+end_src

=OR=

#+begin_src prolog
p(2**N,2**(N+1)) :- N = 0..3.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from one.lp
Solving...
Answer: 1
p(2,4) p(4,8) p(6,12) p(8,16)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.9

For each of the given sets of ground atoms, write a one-rule program that does not contain pooling and has that set as its stable model

a. ~p(0,1) p(1,-1) p(2,1) p(3,-1) p(4,1)~

#+begin_src prolog
p(X,-1**X) :- X=0..4
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from one.lp
Solving...
Answer: 1
p(0,1) p(1,-1) p(2,1) p(3,-1) p(4,1)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.002s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.002s

b. p(1,1), p(2,1) p(2,2), p(3,1) p(3,2) p(3,3), p(4,1) p(4,2) p(4,3) p(4,4)

#+begin_src prolog
p(X,X>=X) :- X = 1..4.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from one_b.lp
Solving...
Answer: 1
p(1,1) p(2,1) p(2,2) p(3,1) p(3,2) p(3,3) p(4,1) p(4,2) p(4,3) p(4,4)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s


Intervals may be used not only in the body of rules as in 2.7 but in the heads as well

E.g. a program containing the fact

    ~p(0..3).~

has the same meaning as the set of 4 facts

    ~p(0). p(1). p(2). p(3).~

And this group can also be abbreviated using pooling:

    ~p(0; 1; 2; 3).~

Each of the constructs, =intervals= or =pooling= has its advantages and limitations

E.g. This "table?" cannot be expressed using =intervals=

#+begin_src prolog
size(france ,65; germany ,83; italy ,61; uk ,64).
#+end_src

And on the other hand expressing a long interval such as ~p(1..100)~ by pooling is impractical

For example the stable model of this one-rule program consists of 64 atoms:

#+begin_src prolog
square(1..8, 1..8).
#+end_src

#+RESULT:
~square(1,1) ... square(8,8)~
            ...
~square(8,1) ... square(8,8)~

*** DONE Exercise 2.10

Considering this program with two facts:

#+begin_src prolog
p(1..2,1..4). p(1..4,1..2).
#+end_src

- How many atoms are to be expected in its stable model?
  - 12

#+RESULTS:
clingo version 5.6.2
Reading from abrv2.lp
Solving...
Answer: 1
p(1,1) p(2,1) p(3,1) p(4,1) p(1,2) p(2,2) p(3,2) p(4,2) p(1,3) p(1,4) p(2,3) p(2,4)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

** Definitions

Many rules in a logic program can be thought of as definitions
One can say, for instance, that rule (1.1) defines the predicate
~large/1~ in terms of the predicate ~p/2~ ???,
rule (2.1) defines ~child/2~ in terms ~parent/2~, and rule (2.7) defines ~p/2~

#+begin_src prolog Rule 2.2
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

*** DONE Exercise 2.11

a. How would you define the predicate ~grandparent/2~ in terms of ~parent/2~ defined?

   #+begin_src prolog
    grandparent(X,Z) :- parent(X,Y), parent(Y,Z).
   #+end_src

b. Running *CLINGO* on the definition of =a.= combined with facts (2.2) what would the stable model produce?


#+RESULTS:
clingo version 5.6.2
Reading from 211.lp
Solving...
Answer: 1
parent(ann,bob) parent(bob,carol) parent(bob,dan) grandparent(ann,carol) grandparent(ann,dan)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.12

a. How would you define the predicate ~sibling/2~ in terms of ~parent/2~?

#+begin_src prolog
siblings(X,Y) :- parent(Z,Y), parent(Z,X), X != Y.
#+end_src

b. If you run *CLINGO* on your definition, combined with facts (2.2), what stable model do you think it will produce?

#+RESULTS:
siblings(carol, dan)
siblings(dan, carol)

*** DONE Exercise 2.13

Assuming that the atom ~enrolled(S,C)~ expresses that student ~S~ is
enrolled in class ~C~, how would you define the set ~enrolled/1~ of all students who are enrolled in at least one class?

#+begin_src prolog
enrolled(S) :- enrolled(S,C).
#+end_src

*** DONE Exercise 2.14

Assuming that the atom ~lives_in(X,C)~ expresses that person ~X~ lives
in city ~C~, and that the atom ~same_city(X,Y)~ expresses that ~X~ and ~Y~ live in the same city, how would you define ~same_city/2~ in terms of ~lives_in/2~?

#+begin_src prolog
same_city(X,Y) :- lives_in(X,C), lives_in(Y,C), X!=Y.
#+end_src

=Solution from the PDF=:

#+begin_src prolog
same_city(X,Y) :- lives_in(X,C), lives_in(Y,C).
#+end_src

*** DONE Exercise 2.15

Assuming that the atom ~age(X,N)~ expresses that person ~X~ is ~N~ years
old, and that the atom ~older(X,Y)~ expresses that ~X~ is older than ~Y~, how would you define ~older/2~ in terms of ~age/2~?

#+begin_src prolog
older(X,Y) :- age(X,N), age(Y,M), X!=Y, N > M.
#+end_src

Sometimes the definition of a predicate consists of several rules. For instance, the pair of rules:

#+begin_src prolog
parent(X,Y) :- father(X,Y).
parent(X,Y) :- mother(X,Y).
#+end_src

defines ~parent/2~ in terms of ~father/2~ and ~mother/2~.

A predicate can be defined recursively. In a recursive definition, the defined predicate occurs not only in the heads of the rules but also in some of the bodies. The definition of ~ancestor/2~ in terms of ~parent/2~ is an example:

#+begin_src prolog Rule 2.8
ancestor(X,Y) :- parent(X,Y).
ancestor(X,Z) :- ancestor(X,Y), ancestor(Y,Z).
#+end_src

*** DONE Exercise 2.16

Running *CLINGO* on the program consisting of rules (2.2) and (2.8),
what stable model would it produce?

#+begin_src prolog
ancestor(X,Y) :- parent(X,Y).
ancestor(X,Z) :- ancestor(X,Y), ancestor(Y,Z).
#+end_src


#+begin_src prolog Rule 2.2
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

If we run *CLINGO* on the program consisting of rules (2.2) and (2.8), what
stable model do you expect it to produce?

#+RESULTS:
ancestor(ann,bob), ancestor(bob,carol), ancestor(bob,dan),
ancestor(ann,carol), ancestor(ann,dan)

Sometimes a predicate cannot be defined in one step, and auxiliary predicates have to be defined first

Consider, for instance, the property of being a prime number between 1 and some upper bound, e.g. 5.

It is easier to define the opposite property of being a composite number between 1 and 5.

#+begin_src prolog Rule 2.9
composite(N) :- N = 1..5, I = 2..N-1, N\I = 0.
#+end_src

Then ~prime/1~ can be defined in terms of ~composite/1~ by the rule:

#+begin_src prolog Rule 2.10
prime(N) :- N = 2..5, not composite(N).
#+end_src

Rule 2.10 is an example of the use of negation in a *CLINGO* program
Recall that an atom is included in a stable model of a program, informally speaking, if it can be derived using its rules Section 1.3

But in what sense can rule 2.10 be used to derive the atom ~prime(3)~?
About the instance

    ~prime(3) :- 3 = 2..5, not composite(3)~

of that rule we can say that the expression

    ~not composite(3)~

in its body is justified in the sense that any attempt to use the rule 2.9
to derive the atom ~composite(3)~ would fail

The negation symbol ~not~, which is often used in logic programs, is said to represent ="negation as failure"=

To emphasize this understanding of negation the rule 2.10 can be read as follows:

    #+BEGIN_QUOTE
    N is a prime number between 1 and 5 if
    it is one of the numbers 2,...,5
    and there is _no evidence_ that it is composite.
    #+END_QUOTE

Negation as failure is an important and difficult subject, and it is discussed in more detail in Section 5.1

*** DONE Exercise 2.17

Two integers are said to be /coprime/ if the only positive integer that divides both of them is 1

We would like to generate the list of all integers from the set $\{1,...,N\}$ that are coprime with an integer $k$.

For example using such a program in the with the cmd-line input of:

    ~clingo coprimes.lp -c n=10 -c k=12~

the expected output is:

    ~coprime(1) coprime(5) coprime(7)~

What rules are necessary in the lines  5 and 10 of the primes.lp file to get this result?

#+begin_src prolog
noncoprime(N) :- N = 2..n, I=2..N, N\I == 0, k\I == 0. %for line 5

coprime(N) :- N = 1..n, not noncoprime(N). %for line 10
#+end_src

*** DONE Exercise 2.18

Every non-negative integer can be represented as the sum of 4 complete squares, for instance:

    ~7 = 22 + 12 + 12 + 12; 10 = 32 + 11 + 02 + 02~

But if we want to represent a given number as the sum of only 3 complete squares, that may be impossible.
The two smallest numbers that require 4 complete squares are 7 and 15.

We would like to generate the list of all integers from the set $\{1,...,n\}$ that cannot be represented as the sum of 3 complete squares.
What rules would you place in Lines 6 and 10 of Listing 2.5 to get such a program?

#+begin_src prolog
three(N) :- N = 1..n, I = 0..n, J = 0..n, K = 0..n, N = I**2+J**2+K**2.
#+end_src

*** DONE Exercise 2.19

Listing 2.6 gives yet another example of a pair of definitions, one on top of the other.
Before defining the property ~fac/1~ of being a factorial, we give a recursive definition of the binary relation ~fac/2~, "the factorial of ~N~ is ~F~." Note that there is no "achieved" comment after Line 5.
Nothing of interest is achieved in the middle of a definition.
Exercise 2.19. Consider the part of the program shown in Listing 2.6 that precedes the comment in Line 7.
What atoms do you expect to see in its stable model if the value of n is 4?

#+begin_src prolog
% Factorials of numbers from 0 to n.

% input: nonnegative integer n.
fac(0 ,1).
fac(N+1,F*(N+1)) :- fac(N,F), N<n.
% achieved: fac/2 = {(0 ,0!) ,... ,(n,n !)}.

fac(F) :- fac(N,F).
% achieved: fac/1 = {0! ,... ,n!}.

#show fac/1.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from fac.lp
Solving...
Answer: 1
fac(1) fac(2) fac(6) fac(24)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s
