* ASP
** DONE Exercise 2.1

Translate this rule into english

#+begin_src prolog
%clingo child.lp
child(X,Y) :- parent(Y,X). %Rule 2.1
#+end_src

*** Solution

Solution X is a child of Y if Y is a parent of X.

** DONE Exercise 2.2

If we run clingo on the program consisting of rule (2.1)

and the rules:

#+begin_src prolog
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

then what stable model do you think it will produce?

*** Solution

Answer: SATISFIABLE
parent(ann,bob). parent(bob,carol). parent(bob,dan) child(bob,ann) child(carol,bob) child(dan,bob)

** Rules

A typical rule consists of a head and a body separated by the *if* symbol :- and with a period at the end

Rules not containing these symbols are viewed as the head without a body

The heads and bodies of rules are formed from /atoms/

#+begin_src prolog Rule 1.1
large(C) :- size(C,S1), size(uk,S2), S1 > S2.
#+end_src

#+begin_src prolog Rule 1.2
size(france,65). size(germany,83). size(italy,61). size(uk,64).
#+end_src

~large(C), size(C,S1), size(uk,S2), size(france,65), size(germany,83), size(italy,61), size(uk,64)~

Within an atom or comparison elements of three types can be seen: /symbolic constants/, /numeric constants/, and /variables/

*** Numeric Constants

A numeric constant is an integer in decimal notation beginning with a with a digit or the *minus* sign

*** Symbolic Constants

A symbolic constant represents is a string of letters, digits and underscores that begins with an lower-case letter

*** Variables

A variable is a string of letters, digits and underscores that begins with an upper-case letter

*** Atom

An atom consists of a /predicate symbol/ - a symbolic constant representing a property or a relation and an optional list of arguments in parentheses

*** Comparison

A comparison consists of two arguments separated by one of the symbols

~= != < > <= >=~ (2.3)

*** Terms

Expressions that can serve as arguments in an atom or comparision are called /terms/

*** Ground

An atom, a rule or another syntactic expression is /ground/ if it does not contain variables

A fact is a ground atom

*CLINGO produces facts in response to rules.*

This can be clarified by considering ~instances~ of rule (1.1) the ground rules that can be obtained from it by substituting constants for variables

The presence of the atom ~large(france)~ in the stable model generated by CLINGO can be justified by the instance

#+begin_src prolog
large(france) :- size(france,65), size(uk,64), 65 > 64.
#+end_src

from rule 1.1 which is obtained from it by substituting the terms:

~france, 65~ and ~64~

for the variables:

~C, S1~, and ~S2~

Both atoms in the body of this instance are among the given facts and the comparison in the body is true.
Consequently this instance justifies including its head ~large(france)~ in the stable model

*** DONE Exercise 2.3

#+begin_src prolog Rule 1.1
large(C) :- size(C,S1), size(uk,S2), S1 > S2.
#+end_src

#+begin_src prolog Rule 1.2
size(france,65). size(germany,83). size(italy,61). size(uk,64).
#+end_src

#+begin_src prolog Rule 2.1
%clingo child.lp
child(X,Y) :- parent(Y,X).
#+end_src

#+begin_src prolog Rule 2.2
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

a. Which instance of rule (1.1) justifies including ~large(germany)~ in the stable model of the program?
   + instance ~large(germany) :- size(germany,83), size(uk,64), 83 > 64.~
b. Which instance of rule (2.1) justifies including ~child(dan,bob)~ in the stable model of program (2.1), (2.2)~
   + instance ~child(dan,bob) :- parent(bob,dan).~

*** DONE Exercise 2.4

Which of the following ground rules and instances of rule (1.1)

a. large(france) :- size(france,65), size(italy,61), 65 > 61.
   - not because the rule 1.1 dictates the comparison with uk instead of italy
b. large(italy) :- size(italy,61), size(uk,64), 61 > 64.
   + ~Instance~
c. large(italy) :- size(italy,83), size(uk,64), 83 > 64.
   + ~Instance~
d. large(7) :- size(7,7), size(uk,7), 7 > 7.
   + ~Instance~

** Comparison again

The last four among the relation symbols (2.3)

~< > <= >=~

are usually applied to numbers, but *CLINGO* allows to apply them to symbolic constants as well

E.g. according to the total order used by *CLINGO* for such comparisons, the symbol ~abracadabra~ is greater than 7

#+begin_src prolog
p :- abracadabra > 7
#+end_src

Stable model: ~p~

#+RESULTS:
clingo version 5.6.2
Reading from comp.lp
Solving...
Answer: 1
p
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

#+begin_src prolog
p :- abracadabra < 7
#+end_src

Stable model: \emptyset (empty model)

#+RESULTS:
clingo version 5.6.2
Reading from comp.lp
Solving...
Answer: 1

SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

** Total Order

The total order chosen by the designers of *CLINGO* has a minimal element and a maximal element denoted by ~#inf~ and ~#sup~

Stable models of some programs are infinite. Consider the example

#+begin_src prolog Rule 2.4
p(X) :- X > 7.
#+end_src

The instance

#+begin_src prolog
p(8) :- 8 > 7.
#+end_src

of this rule justifies including ~p(8)~ in the stable model

The instance

#+begin_src prolog
p(9) :- 9 > 7.
#+end_src

justifies including ~p(9)~ and so on

In response to rule (2.4) *CLINGO* produces an error message saying that there are "unsafe variable" in it

~indicating that the program containing this rule is likely to have an infinite stable model~

** Pooling

When a program contains a group of facts with the same predicate symbol, these facts can be "pooled together" using semicolons

#+begin_src prolog
size(france,65; german,83; italy,61; uk,64).
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from abrv.lp
Solving...
Answer: 1
size(france,65) size(german,83) size(italy,61) size(uk,64)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.5

#+begin_src prolog Rule 2.2
parent(ann,bob). parent(bob,carol). parent(bob,dan).
#+end_src

Use pooling to abbreviate line (2.2)

#+begin_src prolog
parent(ann,bob; bob,carol; bob,dan).
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from abrv.lp
Solving...
Answer: 1
parent(ann,bob) parent(bob,carol) parent(bob,dan)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.6

If you run *CLINGO* on the one-rule program

#+begin_src prolog
p(1,2; 2,4; 4,8; 8,16).
#+end_src

Then what stable model will it produce?

#+RESULTS:
clingo version 5.6.2
Reading from abrv.lp
Solving...
Answer: 1
p(1,2) p(2,4) p(4,8) p(8,16)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

** Directives and Comments

In addition to rules, a logic program may contain /directives/, which tell *CLINGO* how to process the rules and /comments/, which are intended for humans and are disregarded by *CLINGO*

*** show

A ~#show~ directive instructs *CLINGO* to show some elements of the stable model and suppress others

#+begin_src prolog (1.3) output
size(france,65) size(germany,83) size(italy,61) size(uk,64)
large(france) large(germany)
#+end_src

E.g. in the output (1.3) of program (1.1) and (1.2) the first four atoms are irrelevant, they simply repeat the facts included in the program

The output of interest is the list of countries inhabited by more people than the UK, which is given by the last two atoms

*CLINGO* can be instructed to "hide" all atoms that do not begin with the predicate symbol ~large~

#+begin_src prolog
#show large/1
#+end_src

#+begin_src prolog
size(france,65; germany,83; italy,61; uk,64; russia,142).

large(C) :- size(C,S1), size(uk,S2), S1 > S2.

%stelligkeit mit dazu schreiben
%#show large/1.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from sample3.lp
Solving...
Answer: 1
large(france) large(germany) large(russia)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.002s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

In ~#show~ directives and in other cases when referring to /predicate symbols/ used in a logic program, the *arity* is appended =:=the number of arguments= after a slash

In this case the predicate is unary and its arity is ~1~
Specifying the arity is crucial because *CLINGO* allows to use the same character string to represent several predicate symbols on different arities

E.g.

#+begin_src clingo
p. p(a). p(a,b).
#show p/0. #show p/2.
#+end_src

clingo will drop the atom ~p(a)~ from the output, since its predicate symbol ~p/1~ is different from bot ~p/0~ and ~p/2~

#+RESULTS:
clingo version 5.6.2
Reading from show.lp
Solving...
Answer: 1
p p(a,b)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** const

A ~#const~ directive allows to use a symbolic constant as a placeholder for another /constant/, /symbolic/ or /numeric/.

E.g the directive

#+begin_src prolog Rule 2.5
#const c0=uk.
#+end_src

instructs *CLINGO* to substitute ~uk~ for ~c0~ in the rest of the file.

In the presence of directive (2.5), the rule

#+begin_src prolog
large(C) :- size(C,S1), size(c0,S2), S1 > S2.
#+end_src

has the same meaning as (1.1)

** Arithmetic

In the language of *CLINGO*, complex terms can be built from constants and variables using the symbols

~+   *   **  /   \   | |~

for addition, multiplication, exponentiation, integer division, remainder, and absolute value

The symbol ~..~ is used to form intervals. E.g. the expression ~0..3~ denotes the set ~{0,1,2,3}~

To express that the value of ~N~ belongs to this set we write ~N = 0..3~ in this case the ~=~ symbol plays the same role as the symbol ~\in~ in standard mathematical notation

For example the rule:

#+begin_src prolog
p(N,N*N+N+41) :- N = 0..3.
#+end_src

expresses that the pair of integers $(x, x^{2} + x + 41)$ belongs to ~p/2~ whenever ~x~ a number between ~0~ and ~3~. The stable model of this one rule program is

#+RESULTS:
clingo version 5.6.2
Reading from arit.lp
Solving...
Answer: 1
p(0,41) p(1,43) p(2,47) p(3,53)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.7

For each of the given one-rule programs, predict what stable model *CLINGO* is going to produce

a. p(N,N*N+N+41) :- N+1 = 1..4.
   + ~p(0,41) p(1,43) p(2,47) p(3,53)~
b. p(N,N*N+N+41) :- N = -3..3, N >= 0.
   + ~p(0,41) p(1,43) p(2,47) p(3,53)~

=Explanation=: The output is the same for both =a.= and =b.= because of the constraints.
- The expression =a.= can be informally expressed as values for ~N~ that get substituted in the /instance/ ~p(N,N*N+N+41)~ need to satisfy the criteria that the respective ~value + 1~ is in the range of ~1..4~
- The expression =b.= can be informally expressed as values for ~N~ that get substituted in the /instance/ ~p(N,N*N+N+41)~ need to satisfy the criteria that the respective value is in the range from ~-3..3~ *AND* that ~value > 0~

*** DONE Exercise 2.8

Write a one-rule program that does not contain pooling and has the same stable model as the program from exercise (2.6)

#+begin_src prolog 2.6
p(1,2; 2,4; 4,8; 8,16).
#+end_src

#+begin_src prolog 2.8
p(X, X*2) :- N = 1..8, N\2 == 0.
#+end_src

=OR=

#+begin_src prolog
p(2**N,2**(N+1)) :- N = 0..3.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from one.lp
Solving...
Answer: 1
p(2,4) p(4,8) p(6,12) p(8,16)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s

*** DONE Exercise 2.9

For each of the given sets of ground atoms, write a one-rule program that does not contain pooling and has that set as its stable model

a. ~p(0,1) p(1,-1) p(2,1) p(3,-1) p(4,1)~

#+begin_src prolog
p(X,-1**X) :- X=0..4
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from one.lp
Solving...
Answer: 1
p(0,1) p(1,-1) p(2,1) p(3,-1) p(4,1)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.002s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.002s

b. p(1,1), p(2,1) p(2,2), p(3,1) p(3,2) p(3,3), p(4,1) p(4,2) p(4,3) p(4,4)

#+begin_src prolog
p(X,X>=X) :- X = 1..4.
#+end_src

#+RESULTS:
clingo version 5.6.2
Reading from one_b.lp
Solving...
Answer: 1
p(1,1) p(2,1) p(2,2) p(3,1) p(3,2) p(3,3) p(4,1) p(4,2) p(4,3) p(4,4)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s


Intervals may be used not only in the body of rules as in 2.7 but in the heads as well

E.g. a program containing the fact

    ~p(0..3).~

has the same meaning as the set of 4 facts

    ~p(0). p(1). p(2). p(3).~

And this group can also be abbreviated using pooling:

    ~p(0; 1; 2; 3).~

Each of the constructs, =intervals= or =pooling= has its advantages and limitations

E.g. This "table?" cannot be expressed using =intervals=

#+begin_src prolog
size(france ,65; germany ,83; italy ,61; uk ,64).
#+end_src

And on the other hand expressing a long interval such as ~p(1..100)~ by pooling is impractical

For example the stable model of this one-rule program consists of 64 atoms:

#+begin_src prolog
square(1..8, 1..8).
#+end_src

#+RESULT:
~square(1,1) ... square(8,8)~
            ...
~square(8,1) ... square(8,8)~

*** DONE Exercise 2.10

Considering this program with two facts:

#+begin_src prolog
p(1..2,1..4). p(1..4,1..2).
#+end_src

- How many atoms are to be expected in its stable model?
  - 12

#+RESULTS:
clingo version 5.6.2
Reading from abrv2.lp
Solving...
Answer: 1
p(1,1) p(2,1) p(3,1) p(4,1) p(1,2) p(2,2) p(3,2) p(4,2) p(1,3) p(1,4) p(2,3) p(2,4)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.001s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s
